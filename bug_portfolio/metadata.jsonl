{
  "id": 33,
  "name": "decimal_To_Binary",
  "spec": "decimal_To_Binary(N) takes a non-negative integer N and returns an integer whose decimal representation is the binary digits of N. For example, decimal_To_Binary(5) -> 101. For N=0 return 0.",
  "constraints": "N is integer >= 0"
}
{
  "id" : 671,
  "name": "set_Right_most_Unset_Bit",
  "spec": "set_Right_most_Unset_Bit(n) takes a non-negative integer n and sets the rightmost unset (0) bit to 1, returning the new integer. If all bits are set, it returns n unchanged.",
  "constraints": "n is a non-negative integer"
}

{
  "id": 423,
  "name": "gold_mine_problem",
  "spec": "get_max_gold(gold, m, n) takes a 2D list 'gold' representing the amount of gold in each cell of a mine with m rows and n columns. The function returns the maximum amount of gold that can be collected starting from any cell in the first column and moving to the right, right-up, or right-down until reaching the last column.",
  "constraints": "gold is a 2D list of non-negative integers with dimensions m x n, where m and n are positive integers."
}

{
  "id": 423,
  "name": "gold_mine_problem",
  "spec": "get_max_gold(gold, m, n) takes a 2D list 'gold' representing the amount of gold in each cell of a mine with m rows and n columns. The function returns the maximum amount of gold that can be collected starting from any cell in the first column and moving to the right, right-up, or right-down until reaching the last column.",
  "constraints": "gold is a 2D list of non-negative integers with dimensions m x n, where m and n are positive integers."
}

{
  "id": 334,
  "name": "check_Validity",
  "spec":"check_Validity(a, b, c) returns True if the three given sides can form a valid triangle based on the triangle inequality rule, otherwise returns False.  
  A triangle is valid if and only if the sum of any two sides is greater than the third side, and all sides are positive. ",
  "constraints": "a, b, c are positive real numbers."
}


{
  "id": 592,
  "name": "binomial coefficient",
  "bug_description": "Changed the inner loop from range(min(i, k), 0, -1) to range(min(i, k), -1, -1) in the binomial coefficient calculation. This causes the loop to iterate one extra time, attempting to access C[j-1] when j=0, which accesses C[-1] (the last element of the array due to Python's negative indexing), corrupting the Pascal's triangle computation.",
  "impact": "The bug produces incorrect binomial coefficients for most inputs because it adds wrong values during the dynamic programming calculation. The error is subtle because it doesn't crash (negative indexing wraps around in Python) but silently produces wrong results. This violates fundamental mathematical properties including Pascal's identity, symmetry property, and row sum equaling 2^n.",
  "spec": "binomial_Coeff(n, k) computes the binomial coefficient C(n, k), which represents the number of ways to choose k items from n items. It uses dynamic programming based on Pascal's triangle. sum_Of_product(n) computes C(2n, n-1), which is the binomial coefficient of 2n choose n-1. Mathematical properties: C(n, 0) = 1 and C(n, n) = 1 for all n >= 0; C(n, k) = C(n, n-k) (symmetry property); C(n, k) = C(n-1, k-1) + C(n-1, k) (Pascal's identity); Sum of row n: C(n, 0) + C(n, 1) + ... + C(n, n) = 2^n",
  "constraints": "n >= 0, 0 <= k <= n for binomial_Coeff; n >= 1 for sum_Of_product",
}


