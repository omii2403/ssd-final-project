
{
  "id" : 671,
  "name": "set_Right_most_Unset_Bit",
  "spec": "set_Right_most_Unset_Bit(n) takes a non-negative integer n and sets the rightmost unset (0) bit to 1, returning the new integer. If all bits are set, it returns n unchanged.",
  "constraints": "n is a non-negative integer",
  "bug_description": "When n = 0, the function returns 0 instead of 1",
  "impact": "This bug causes the function to return incorrect results for the input n = 0, where the expected output is 1, but the function returns 0. This violates the intended behavior of setting the rightmost unset bit and can lead to confusion when using the function for bit manipulation tasks."
}

{
  "id": 550,
  "name": "find_Max",
  "spec": "find_Max(arr, low, high) takes a list 'arr' (sorted and rotated array) and two indices 'low' and 'high', and returns the maximum value in the sublist arr[low:high+1] using a divide-and-conquer approach.",
  "constraints": "arr is a list of integers, and low and high are valid indices within the bounds of arr.",
  "bug_description": "the condition if (arr[low] >= arr[mid]) should be if (arr[low] > arr[mid]), as using >= can cause incorrect recursion and miss the maximum element in certain cases.",
  "impact": "This bug causes the function to incorrectly identify the maximum element in certain rotated sorted arrays, leading to inaccurate results and violating the expected behavior of the algorithm."
}

{
  "id": 423,
  "name": "get_max_gold",
  "spec": "get_max_gold(gold, m, n) takes a 2D list 'gold' representing the amount of gold in each cell of a mine with m rows and n columns. The function returns the maximum amount of gold that can be collected starting from any cell in the first column and moving to the right, right-up, or right-down until reaching the last column.",
  "constraints": "gold is a 2D list of non-negative integers with dimensions m x n, where m and n are positive integers.",
  "bug_description": "The final answer calculation loop doesn't check for the last row's first element. ie loop is running till m-2",
  "impact": "Last row's first element is not considered while calculating the final answer, leading to incorrect results when the maximum gold path starts from that cell."
}

{
  "id": 453,
  "name": "sumofFactors",
  "spec": "sumofFactors is python function to find the sum of even factors of a number. The function takes a positive integer n as input and returns the sum of all its even factors.",
  "constraints": "n is a positive integer",
  "bug_description": "The function doesn't correctly handle the case when n is 2. It should return 2 as the sum of even factors but due to a missing condition, it returns 3 instead.",
  "impact": "This bug causes incorrect results for the input n = 2, where the expected output is 2, but the function returns 3. This violates the mathematical definition of factors and can lead to confusion when using the function for calculations involving even factors."
}

{
  "id": 657, 
  "name": "first_Digit",
  "spec": "first_Digit(n) takes a non-negative integer n and returns the first digit of n! (n factorial).",
  "constraints": "n is a non-negative integer", 
  "bug_description": " The while loop that removes trailing digits runs only while fact is greater than 10, which causes it to stop prematurely when fact is exactly 10, leading to incorrect results for certain inputs.",
  "impact": "This bug causes incorrect results for inputs where n! ends with a zero, such as n = 5 (5! = 120). The expected first digit is 1, but due to the bug, the function returns 2. This violates the mathematical definition of the first digit of a number and can lead to confusion when using the function for calculations involving factorials."
}  

{
  "id": 663,
  "name": "find_max_val",
  "spec": "find_max_val(n, x, y) takes three integers n, x, and y, and returns the largest integer k such that 0 <= k <= n and k modulo x equals y. If no such k exists, it returns -1.",
  "constraints": "n, x, and y are integers with n >= 0, x > 0, and 0 <= y < x.",
  "bug_description": "return (ans if (ans > 0 and ans <= n) else -1) should be return (ans if (ans >= 0 and ans <= n) else -1) to correctly handle the case when k = 0 is a valid solution.",
  "impact": "This bug causes the function to incorrectly return -1 when the largest valid k is 0, which violates the problem constraints and leads to incorrect results for certain inputs."
}

{
  "id": 522,
  "name": "bitonic_subsequence",
  "spec": "lbs(arr) takes a list of integers and returns the length of the longest bitonic subsequence. A bitonic subsequence is a subsequence that first strictly increases and then strictly decreases. Either the increasing or decreasing part can be empty. For example, [1,2,3,2,1] has a longest bitonic subsequence of length 5. The subsequence [1,11,2,10,4,5,2,1] has longest bitonic subsequence length 6.",
  "constraints": "arr is a list of integers, can be empty or have duplicates",
  "bug_description": "Changed the strict inequality operator > to non-strict inequality operator >= in the Longest Increasing Subsequence (LIS) comparison on line 6. The condition was changed from arr[i] > arr[j] to arr[i] >= arr[j].",
  "impact": "This bug causes the function to incorrectly calculate the length of the longest bitonic subsequence when the input list contains duplicate elements. By using a non-strict comparison, the algorithm may count equal elements as part of an increasing sequence, which violates the definition of a strictly increasing subsequence. As a result, the final computed length of the bitonic subsequence may be longer than it should be, leading to incorrect results for inputs with repeated values."
}

{
  "id": 592,
  "name": "binomial_Coeff",
  "spec": "binomial_Coeff(n, k) computes the binomial coefficient C(n, k), which represents the number of ways to choose k items from n items. It uses dynamic programming based on Pascal's triangle. sum_Of_product(n) computes C(2n, n-1), which is the binomial coefficient of 2n choose n-1. Mathematical properties: C(n, 0) = 1 and C(n, n) = 1 for all n >= 0; C(n, k) = C(n, n-k) (symmetry property); C(n, k) = C(n-1, k-1) + C(n-1, k) (Pascal's identity); Sum of row n: C(n, 0) + C(n, 1) + ... + C(n, n) = 2^n",
  "constraints": "n >= 0, 0 <= k <= n for binomial_Coeff; n >= 1 for sum_Of_product",
  "bug_description": "The function is called with incorrect parameters in sum_Of_product. Changed binomial_Coeff(2 * n, n - 1) to binomial_Coeff(2 * n, n).",
  "impact": "This bug causes sum_Of_product to return incorrect results for all inputs n >= 1. The intended calculation is C(2n, n-1), but due to the incorrect parameter, it computes C(2n, n) instead. This violates the mathematical definition of the problem and leads to inaccurate results in any application relying on this function."
}

{
  "id": 601,
  "name": "max_chain_length",
  "spec": "max_chain_length(arr, n) finds the length of the maximum chain of pairs using dynamic programming. A chain is formed when pairs satisfy strict inequality: the second element of one pair must be strictly less than the first element of the next pair (b < c for pairs (a,b) and (c,d)).",
  "constraints": "n >= 1, arr[i].a < arr[i].b for all valid pairs",
  "bug_description": "Changed the strict inequality operator > to non-strict inequality operator >= in the chain comparison condition. Changed arr[i].a > arr[j].b to arr[i].a >= arr[j].b.",
  "impact": "Violates the definition of a valid chain of pairs. A chain is valid only if the second element of the previous pair is strictly less than the first element of the current pair. By using >=, the algorithm incorrectly allows chains where arr[i].a == arr[j].b (touching pairs), which should not form valid chain links. This produces inflated maximum chain lengths for arrays containing pairs with touching boundaries, such as (1,2) and (2,3) incorrectly chaining together."
}

{
  "id": 685,
  "name": "sum_Of_Primes",
  "spec": "sum_Of_Primes(n) takes a positive integer n and returns the sum of all prime numbers between 1 and n (inclusive).",
  "constraints": "n is a positive integer",
  "bug_description": " The condition in the while loop should be 'while p * p <= n:' instead of 'while p * p < n:'. This change is necessary to ensure that all prime factors up to the square root of n are considered, including the case when p * p equals n.",
  "impact": "This bug causes the function to miss certain prime numbers when n is a perfect square. For example, when n = 9, the function fails to mark 3 as non-prime because it does not check p * p = 9. As a result, the sum of primes calculated by the function will be incorrect for inputs that are perfect squares, leading to inaccurate results."
}

{
  "id": 806,
  "name": "max_run_uppercase",
  "spec": "max_run_uppercase(test_str) takes a string test_str and returns the length of the longest consecutive sequence (run) of uppercase characters in the string.",
  "constraints": "test_str is a non-empty string containing alphabetic characters.",
  "bug_description" : " In the else block, the line 'cnt = -1' incorrectly resets the count of consecutive uppercase characters to -1 instead of 0. This causes the function to undercount the length of uppercase runs following a non-uppercase character.",
  "impact": "This bug causes the function to return incorrect results for strings where uppercase runs are separated by non-uppercase characters. For example, in the string 'aaAAABBBccDDDDDeE', the longest run of uppercase characters is 'DDDDD' with a length of 5. However, due to the bug, the function returns 4 instead of 5, leading to inaccurate results."
}

{
  "id": 815,
  "name": "sort_by_dnf",
  "spec": "sort_by_dnf(arr, n) takes a list arr consisting of only 0s, 1s, and 2s, and an integer n representing the length of the list. The function sorts the list in-place using the Dutch National Flag algorithm and returns the sorted list.",
  "constraints": "arr is a list of integers containing only 0s, 1s, and 2s; n is a positive integer representing the length of arr.",
  "bug_description": " In the case where arr[mid] == 1, the line 'mid = mid + 2' incorrectly increments mid by 2 instead of 1.",
  "impact": "This causes the algorithm to skip over elements, leading to incorrect sorting of the array."
}

{
  "id": 822,
  "name": "pass_validity",
  "spec": "pass_validity(p) takes a string p representing a password and returns True if the password is valid according to the following criteria: it must be between 6 and 12 characters long, contain at least one lowercase letter, one uppercase letter, one digit, one special character from the set {$, #, @}, and must not contain any whitespace characters. If the password does not meet all these criteria, the function returns False.",
  "constraints": "p is a non-empty string.",
  "bug_description": "In  the line checking for whitespace characters, the regex pattern is incorrectly written as '\\s ' (with an extra space) instead of '\\s'. This causes the function to fail to identify passwords that contain whitespace characters, leading to incorrect validation results.",
  "impact": " This bug causes the function to incorrectly validate passwords that contain whitespace characters. The incorrect regex pattern fails to match whitespace, allowing passwords with spaces, tabs, or other whitespace characters to be considered valid. This violates the password policy and can lead to security vulnerabilities by permitting weak passwords that do not meet the specified criteria."
}

{
  "id": 826,
  "name": "check_Type_Of_Triangle",
  "spec": "check_Type_Of_Triangle(a, b, c) takes three positive real numbers a, b, and c representing the lengths of the sides of a triangle. The function returns a string indicating the type of triangle based on the lengths of its sides: 'Right-angled Triangle' if it is a right-angled triangle, 'Obtuse-angled Triangle' if it is an obtuse-angled triangle, and 'Acute-angled Triangle' if it is an acute-angled triangle.",
  "constraints": "a, b, c are positive real numbers that can form a valid triangle.",
  "bug_description": " The condition to check for a right-angled triangle is incorrect. It should use addition for all comparisons instead of subtraction. The correct condition is 'if (sqa == sqb + sqc or sqb == sqa + sqc or sqc == sqa + sqb):' to properly apply the Pythagorean theorem. ", 
  "impact": "This bug causes the function to incorrectly classify certain triangles. For example, a triangle with sides 3, 4, and 5 should be classified as a right-angled triangle, but due to the incorrect condition, it may not be recognized as such. This leads to inaccurate results and misclassification of triangle types."
}

{
  "id": 831,
  "name": "count_Pairs",
  "spec": "count_Pairs(arr, n) takes a list arr of integers and an integer n representing the length of the list. The function returns the count of pairs of equal elements in the list. A pair is defined as two elements arr[i] and arr[j] such that arr[i] == arr[j] and i < j.",
  "constraints": "arr is a list of integers; n is a positive integer representing the length of arr.",
  "bug_description": "The inner loop should iterate from i+1 to n instead of i+1 to n-1 to ensure all elements are considered.",
  "impact": "This bug causes the function to miss counting pairs that include the last element of the array, leading to an incorrect total count of pairs."
}

{
  "id": 834,
  "name": "generate_matrix",
  "spec": "generate_matrix(n) takes a positive integer n and returns an n x n square matrix filled with elements from 1 to n^2 in spiral order.",
  "constraints": "n is a positive integer",
  "bug_description": "The condition in the while loop should be 'if current >= n*n:' instead of 'if current > n*n:'. This change is necessary to ensure that the loop continues until all n^2 elements are filled in the matrix, including the case when current equals n^2.",
  "impact": "This bug causes the function to produce an incomplete matrix when n is greater than 1."
}

{
  "id": 783,
  "name": "rgb_to_hsv",
  "spec": "rgb_to_hsv(r, g, b) converts a color from the RGB color space to the HSV (Hue, Saturation, Value) color space. The inputs r, g, and b are integers in the range 0 to 255, representing the red, green, and blue components of the color. The function returns a tuple (h, s, v) where h is the hue in degrees in the range [0, 360), s is the saturation in percentage in the range [0, 100], and v is the value/brightness in percentage in the range [0, 100]. For grayscale colors where r == g == b, the saturation must be 0 and the hue is defined as 0.",
  "constraints": "r, g, and b are integers between 0 and 255 inclusive. The function must handle all valid RGB colors, including pure primaries, secondary colors, grayscale values, near-black, and near-white colors.",
  "bug_description": "In the branch where the green component is the maximum (mx == g), the formula for computing the hue uses an incorrect constant offset: it adds 60 degrees instead of 120 degrees. Specifically, it computes h = (60 * ((b - r) / df) + 60) % 360, whereas the correct formula should use +120. This shifts the hue for green-dominant colors into the wrong sector of the color wheel.",
  "impact": "For colors where the green component is the largest and the color is not grayscale, the computed hue value is incorrect. For example, a pure green RGB color (0, 255, 0) should have a hue of approximately 120 degrees, but the buggy implementation produces a hue near 60 degrees. This leads to misrepresentation of green-dominant colors in HSV-based processing, which can cause downstream errors in tasks like color-based segmentation, filtering, or visualization."
}

{
  "id": 836,
  "name": "max_sub_array_sum",
  "spec": "max_sub_array_sum(a, size) takes a list of integers a of length size and returns the length of a contiguous subarray whose sum is maximal among all contiguous subarrays of a. If multiple subarrays have the same maximum sum, the function is intended to return the length of the earliest such subarray (the one with the smallest starting index). The return value is a positive integer between 1 and size.",
  "constraints": "a is a non-empty list of integers, and size is a positive integer equal to len(a). Elements of a may be negative, zero, or positive. The function must handle arrays where all values are negative, all are non-negative, or a mix of both.",
  "bug_description": "In the condition that updates the current best subarray, the comparison uses '<=' instead of '<'. Specifically, the buggy code uses 'if max_so_far <= max_ending_here:' instead of 'if max_so_far < max_ending_here:'. This changes how ties are broken when multiple subarrays share the same maximum sum, causing the algorithm to prefer later subarrays instead of the earliest one.",
  "impact": "When there are multiple contiguous subarrays with the same maximum sum, the function may return the length of a later subarray rather than the earliest one. This leads to incorrect behavior relative to the intended specification. For example, in some arrays where two different subarrays have the same maximum sum but different lengths, the buggy implementation may report the length of the later subarray, disagreeing with the expected result produced by a correct, deterministic tie-breaking rule based on earliest starting index."
}

{
  "id": 541,
  "name": "get_sum",
  "spec": "get_sum(n) takes a positive integer n and returns the sum of all proper divisors of n, where proper divisors are positive integers less than n that divide n evenly. For example, get_sum(6) should return 6 (1 + 2 + 3), get_sum(28) should return 28, and get_sum(10) should return 8 (1 + 2 + 5). The function may return the result as a float due to internal division, but numerically it must equal the arithmetic sum of the proper divisors.",
  "constraints": "n is a positive integer greater than or equal to 1. The function must correctly handle prime numbers, perfect numbers, composite numbers, and perfect squares, and should operate efficiently for moderately large n.",
  "bug_description": "The loop that searches for divisors iterates while i < sqrt(n) instead of i <= sqrt(n). This off-by-one error causes the algorithm to skip the divisor equal to sqrt(n) when n is a perfect square, so one of the divisor pairs is never fully accounted for.",
  "impact": "For perfect square values of n, one of the factors equal to sqrt(n) is omitted, leading to an underestimated sum of proper divisors. For example, for n = 16 the correct sum of proper divisors is 15 (1 + 2 + 4 + 8), but the buggy implementation only counts divisors arising from smaller i values and then subtracts n, producing an incorrect result. This can cause misclassification of numbers in downstream tasks that rely on accurate divisor sums, such as checking for perfect or amicable numbers."
}

{
  "id": 819,
  "name": "count_duplic",
  "spec": "count_duplic(lists) takes a list of numbers and returns two lists: one containing the elements and the other containing the frequency of consecutive duplicate elements.",
  "constraints": "lists is a non-empty list of integers.",
  "bug_description": "The line 'element.append(lists[i])' at the end of the function should be 'element.append(lists[i+1])' to correctly append the last unique element after the loop completes.",
  "impact": "This bug causes the function to miss appending the last unique element in the input list, leading to incorrect results when the last element is different from the second last."
}

{
  "id": 706,
  "name": "is_subset",
  "spec": "is_subset(arr1, m, arr2, n) takes two lists arr1 and arr2, along with their respective lengths m and n. The function returns True if arr2 is a subset of arr1, meaning all elements of arr2 are present in arr1. Otherwise, it returns False.",
  "constraints": "arr1 and arr2 are lists; m and n are positive integers representing the lengths of arr1 and arr2 respectively.",
  "bug_description": "The 2nd for loop is starting from 1 instead of 0.",
  "impact": "This bug causes the function to incorrectly return False when the first element of arr2 is not present in arr1, leading to inaccurate subset checks."
}

{
  "id": 733,
  "name": "find_first_occurrence",
  "spec": "find_first_occurrence(A, x) takes a sorted list A and an integer x, and returns the index of the first occurrence of x in A. If x is not present in A, the function returns -1.",
  "constraints": "A is a sorted list of integers; x is an integer.",
  "bug_description": "The condition 'elif x < A[mid] - 1:' should be 'elif x < A[mid]:'.",
  "impact": "This bug causes the function to incorrectly search for the first occurrence of x in the list A, leading to incorrect results when x is present in A."
}

{
  "id": 548,
  "name": "longest_increasing_subsequence",
  "spec": "longest_increasing_subsequence(arr) takes a list of integers arr and returns the length of the longest increasing subsequence (LIS) in arr using dynamic programming.",
  "constraints": "arr is a list of integers, can be empty or have duplicates",
  "bug_description": "In 2nd loop, range for i is set to 1 to n instead of 0 to n.",
  "impact": "This bug causes the function to miss considering the first element of the array when calculating the longest increasing subsequence, leading to incorrect results."
}
