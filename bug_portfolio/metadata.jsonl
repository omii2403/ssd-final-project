
{
  "id" : 671,
  "name": "set_Right_most_Unset_Bit",
  "spec": "set_Right_most_Unset_Bit(n) takes a non-negative integer n and sets the rightmost unset (0) bit to 1, returning the new integer. If all bits are set, it returns n unchanged.",
  "constraints": "n is a non-negative integer",
  "bug_description": "When n = 0, the function returns 0 instead of 1"
}

{
  "id": 423,
  "name": "gold_mine_problem",
  "spec": "get_max_gold(gold, m, n) takes a 2D list 'gold' representing the amount of gold in each cell of a mine with m rows and n columns. The function returns the maximum amount of gold that can be collected starting from any cell in the first column and moving to the right, right-up, or right-down until reaching the last column.",
  "constraints": "gold is a 2D list of non-negative integers with dimensions m x n, where m and n are positive integers.",
  "bug_description": "The final answer calculation loop doesn't check for the last row's first element. ie loop is running till m-2"
}



{
  "id": 334,
  "name": "check_Validity",
  "spec":"check_Validity(a, b, c) returns True if the three given sides can form a valid triangle based on the triangle inequality rule, otherwise returns False.  
  A triangle is valid if and only if the sum of any two sides is greater than the third side, and all sides are positive. ",
  "constraints": "a, b, c are positive real numbers."
}

{
   "id": 522,
   "name": "bitonic subsequence",
   "bug_description": "Changed the strict inequality operator > to non-strict inequality operator >= in the Longest Increasing Subsequence (LIS) comparison on line 6. The condition was changed from arr[i] > arr[j] to arr[i] >= arr[j].",
   
    "spec": "lbs(arr) takes a list of integers and returns the length of the longest bitonic subsequence. A bitonic subsequence is a subsequence that first strictly increases and then strictly decreases. Either the increasing or decreasing part can be empty. For example, [1,2,3,2,1] has a longest bitonic subsequence of length 5. The subsequence [1,11,2,10,4,5,2,1] has longest bitonic subsequence length 6.",
    "constraints": "arr is a list of integers, can be empty or have duplicates",
}
{
  "id": 592,
  "name": "binomial coefficient",
  "bug_description": "Changed the inner loop from range(min(i, k), 0, -1) to range(min(i, k), -1, -1) in the binomial coefficient calculation. This causes the loop to iterate one extra time, attempting to access C[j-1] when j=0, which accesses C[-1] (the last element of the array due to Python's negative indexing), corrupting the Pascal's triangle computation.",
  "impact": "The bug produces incorrect binomial coefficients for most inputs because it adds wrong values during the dynamic programming calculation. The error is subtle because it doesn't crash (negative indexing wraps around in Python) but silently produces wrong results. This violates fundamental mathematical properties including Pascal's identity, symmetry property, and row sum equaling 2^n.",
  "spec": "binomial_Coeff(n, k) computes the binomial coefficient C(n, k), which represents the number of ways to choose k items from n items. It uses dynamic programming based on Pascal's triangle. sum_Of_product(n) computes C(2n, n-1), which is the binomial coefficient of 2n choose n-1. Mathematical properties: C(n, 0) = 1 and C(n, n) = 1 for all n >= 0; C(n, k) = C(n, n-k) (symmetry property); C(n, k) = C(n-1, k-1) + C(n-1, k) (Pascal's identity); Sum of row n: C(n, 0) + C(n, 1) + ... + C(n, n) = 2^n",
  "constraints": "n >= 0, 0 <= k <= n for binomial_Coeff; n >= 1 for sum_Of_product",
}


